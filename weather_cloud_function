import os
import functions_framework
from pytz import timezone
from datetime import datetime
import pandas as pd
import requests
from sqlalchemy import create_engine
import pysqlite3
import sys
sys.modules["sqlite3"] = pysqlite3


@functions_framework.http
def weather_pushing(request):
    schema = "cities"  
    host = "34.79.76.172"
    user = "root"
    password = os.environ['password']  
    port = 3306
    
    connection_string = f'mysql+pymysql://{user}:{password}@{host}:{port}/{schema}'


    try:
        # Fetch data from database
        cities_df = pd.read_sql("SELECT * FROM city", con=connection_string)
        existing_weather_df = pd.read_sql("SELECT * FROM weather", con=connection_string)
        
        berlin_tz = timezone("Europe/Berlin")
        API_key = os.environ["WEATHER_API_KEY"]
        all_weather_data = []
        
        for _, row in cities_df.iterrows():
            response = requests.get(
                "https://api.openweathermap.org/data/2.5/forecast",
                params={
                    "q": row["city_name"],
                    "units": "metric",
                    "appid": API_key,
                }
            )
            if response.status_code != 200:
                print(f"Failed to fetch weather for {row['city_name']}")
                continue
                
            weather_json = response.json()

            for item in weather_json["list"]:
                all_weather_data.append({
                    "city_id": row["city_id"],
                    "city": weather_json["city"]["name"],
                    "temperature": item["main"]["temp"],
                    "humidity": item["main"]["humidity"],
                    "feels_like": item["main"]["feels_like"],
                    "rain": item.get("rain", {}).get("3h", 0),
                    "snow": item.get("snow", {}).get("3h", 0),
                    "clouds": item["clouds"]["all"],
                    "wind": item["wind"]["speed"],
                    "weather": item["weather"][0]["description"],
                    "dt": item["dt"],
                    "time_retrieved": datetime.now(berlin_tz),
                })
        
        if not all_weather_data:
            return "No weather data retrieved", 400
        
        weather_df = pd.DataFrame(all_weather_data)
        weather_df["time_retrieved"] = pd.to_datetime(weather_df["time_retrieved"])
        
        merged_df = pd.merge(
            weather_df,
            existing_weather_df[["city_id", "dt"]],  # Only need these columns for comparison
            on=["city_id", "dt"],
            how="left",
            indicator=True
        )

        new_weather_df = merged_df[merged_df["_merge"] == "left_only"].drop(columns=["_merge"])
        
        if new_weather_df.empty:
            return "No new weather data to insert", 200
        
        new_weather_df.to_sql('weather', if_exists="append", con=connection_string, index=False)
        
        return f"Successfully inserted {len(new_weather_df)} new weather records", 200
        
    except Exception as e:
        return f"Error: {str(e)}", 500

